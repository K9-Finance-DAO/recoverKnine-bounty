import { useEffect, useMemo, useState } from 'react'
import { MAINNET_ID, KNINE_TOKEN, BOUNTY_CONTRACT, KNINE_AMOUNT, ERC20_ABI, BOUNTY_ABI, EXPLOITER_ADDR } from '../lib/knine'
import { useAccount, useChainId, usePublicClient, useWalletClient, useSwitchChain } from 'wagmi'
import { formatEther, formatUnits } from 'viem'

export function ExploiterAssist() {
  const chainId = useChainId()
  const { address, isConnected } = useAccount()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()
  const { switchChain, isPending: switching } = useSwitchChain()

  const onMainnet = chainId === MAINNET_ID

  const [knineDec, setKnineDec] = useState<number>(18)
  const [knineSym, setKnineSym] = useState<string>('KNINE')
  const [allowance, setAllowance] = useState<bigint | undefined>()
  const [acceptedAt, setAcceptedAt] = useState<bigint | undefined>()
  const [ethBalance, setEthBalance] = useState<bigint | undefined>()
  const [ethUsd, setEthUsd] = useState<number | undefined>()
  const [busy, setBusy] = useState<'approve' | 'accept' | undefined>()
  const [error, setError] = useState<string | undefined>()
  const [txHash, setTxHash] = useState<`0x${string}` | undefined>()

  // Fetch token metadata once on mainnet
  useEffect(() => {
    if (!publicClient || !onMainnet) return
    ;(async () => {
      try {
        const [dec, sym] = await Promise.all([
          publicClient.readContract({ address: KNINE_TOKEN, abi: ERC20_ABI, functionName: 'decimals' }) as Promise<number>,
          publicClient.readContract({ address: KNINE_TOKEN, abi: ERC20_ABI, functionName: 'symbol' }) as Promise<string>,
        ])
        setKnineDec(dec)
        setKnineSym(sym)
      } catch {}
    })()
  }, [publicClient, onMainnet])

  // Fetch dynamic values
  async function refresh() {
    if (!publicClient || !onMainnet) return
    try {
      if (address) {
        const a = await publicClient.readContract({
          address: KNINE_TOKEN,
          abi: ERC20_ABI,
          functionName: 'allowance',
          args: [address, BOUNTY_CONTRACT],
        }) as bigint
        setAllowance(a)
      } else {
        setAllowance(undefined)
      }

      const [accAt, bal] = await Promise.all([
        publicClient.readContract({ address: BOUNTY_CONTRACT, abi: BOUNTY_ABI, functionName: 'acceptedAt' }) as Promise<bigint>,
        publicClient.getBalance({ address: BOUNTY_CONTRACT })
      ])
      setAcceptedAt(accAt)
      setEthBalance(bal)
    } catch (e) {
      console.error(e)
    }
  }

  useEffect(() => { refresh() }, [publicClient, onMainnet, address])

  // Price fetch for ETH
  useEffect(() => {
    let alive = true
    async function load() {
      try {
        const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd', { cache: 'no-store' })
        const json = await res.json()
        const price = Number(json?.ethereum?.usd)
        if (alive && Number.isFinite(price)) setEthUsd(price)
      } catch {}
    }
    load()
    const t = setInterval(load, 60_000)
    return () => { alive = false; clearInterval(t) }
  }, [])

  const allowanceOk = useMemo(() => (allowance ?? 0n) >= KNINE_AMOUNT, [allowance])

  async function handleApprove() {
    if (!walletClient || !publicClient || !address) return
    try {
      setBusy('approve')
      setError(undefined)
      const hash = await walletClient.writeContract({
        address: KNINE_TOKEN,
        abi: ERC20_ABI,
        functionName: 'approve',
        args: [BOUNTY_CONTRACT, KNINE_AMOUNT],
        account: address,
        chain: publicClient.chain
      })
      setTxHash(hash)
      await publicClient.waitForTransactionReceipt({ hash })
      await refresh()
    } catch (e: any) {
      console.error(e)
      setError(e?.shortMessage || e?.message || 'Approve failed')
    } finally {
      setBusy(undefined)
    }
  }

  async function handleAccept() {
    if (!walletClient || !publicClient || !address) return
    try {
      setBusy('accept')
      setError(undefined)
      const hash = await walletClient.writeContract({
        address: BOUNTY_CONTRACT,
        abi: BOUNTY_ABI,
        functionName: 'accept',
        args: [],
        account: address,
        chain: publicClient.chain
      })
      setTxHash(hash)
      await publicClient.waitForTransactionReceipt({ hash })
      await refresh()
    } catch (e: any) {
      console.error(e)
      setError(e?.shortMessage || e?.message || 'accept() failed')
    } finally {
      setBusy(undefined)
    }
  }

  const acceptedAtNum = Number(acceptedAt ?? 0n)
  const acceptedAtUtc = acceptedAtNum > 0 ? new Date(acceptedAtNum * 1000).toUTCString() : '—'
  const ethBalFmt = ethBalance ? formatEther(ethBalance) : '—'
  const ethUsdFmt = ethBalance && ethUsd ? (Number(formatEther(ethBalance)) * ethUsd).toLocaleString(undefined, { style: 'currency', currency: 'USD' }) : '—'
  const allowanceFmt = allowance !== undefined ? formatUnits(allowance, knineDec) : '—'

  return (
    <div className="col" style={{ gap: 16 }}>
      <div className="muted">
        Assist page for the Exploiter to approve KNINE to the bounty contract and freeze the bounty time via accept().
      </div>

      {!isConnected && <div className="pill" style={{ borderColor: '#cc5' }}>Connect a wallet above.</div>}

      {isConnected && !onMainnet && (
        <div className="row" style={{ alignItems: 'center', gap: 8 }}>
          <div className="pill" style={{ borderColor: '#d55' }}>Wrong network</div>
          <button onClick={() => switchChain({ chainId: MAINNET_ID })} disabled={switching}>Switch to Ethereum Mainnet</button>
        </div>
      )}

      <div className="grid">
        <div>
          <div className="muted">Bounty Contract</div>
          <div className="mono">{BOUNTY_CONTRACT}</div>
        </div>
        <div>
          <div className="muted">KNINE Token</div>
          <div className="mono">{KNINE_TOKEN}</div>
        </div>
      </div>

      <div className="grid">
        <div>
          <div className="muted">Contract ETH Balance</div>
          <div className="row" style={{ gap: 8, alignItems: 'baseline' }}>
            <div className="mono">{ethBalFmt} ETH</div>
            <div className="muted">{ethUsdFmt}</div>
          </div>
        </div>
        <div>
          <div className="muted">acceptedAt</div>
          <div className="mono">{acceptedAt ? String(acceptedAt) : '0'}</div>
          <div className="muted">{acceptedAtUtc}</div>
        </div>
      </div>

      <div className="grid">
        <div>
          <div className="muted">Your Allowance → Bounty</div>
          <div className="mono">{allowanceFmt} {knineSym}</div>
        </div>
        <div>
          <div className="muted">Required Amount</div>
          <div className="mono">{formatUnits(KNINE_AMOUNT, knineDec)} {knineSym}</div>
        </div>
      </div>

      {address && address.toLowerCase() !== EXPLOITER_ADDR.toLowerCase() && (
        <div className="pill" style={{ borderColor: '#d55' }}>
          Warning: accept() can only be called by the specific exploiter address {EXPLOITER_ADDR}.
        </div>
      )}

      <div className="row">
        <button onClick={handleApprove} disabled={!isConnected || !onMainnet || busy !== undefined}>
          {busy === 'approve' ? 'Approving…' : `Approve ${formatUnits(KNINE_AMOUNT, knineDec)} ${knineSym}`}
        </button>
        <button onClick={handleAccept} disabled={!isConnected || !onMainnet || !allowanceOk || busy !== undefined}>
          {busy === 'accept' ? 'Accepting…' : 'Call accept()'}
        </button>
      </div>

      {txHash && (
        <div className="muted">Last Tx: <span className="mono">{txHash}</span></div>
      )}
      {error && (
        <div style={{ color: '#f77' }}>{error}</div>
      )}

      <div className="hint">Data updates automatically after transactions confirm. Prices via CoinGecko.</div>
    </div>
  )
}

