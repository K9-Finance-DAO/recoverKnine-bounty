import { useEffect, useMemo, useState } from 'react'
import { MAINNET_ID, HARDHAT_CHAIN_ID, KNINE_TOKEN, BOUNTY_CONTRACT, KNINE_AMOUNT, ERC20_ABI, BOUNTY_ABI, EXPLOITER_ADDR, TREASURY_ADDR } from '../lib/knine'
import { useAccount, useChainId, usePublicClient, useWalletClient, useSwitchChain } from 'wagmi'
import { formatEther, formatUnits, hexToString, isAddress, stringToHex } from 'viem'

export function ExploiterAssist() {
  const chainId = useChainId()
  const { address, isConnected } = useAccount()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()
  const { switchChain, isPending: switching } = useSwitchChain()

  const allowDev = import.meta.env.DEV || import.meta.env.VITE_ENABLE_DEV_CHAIN === 'true'
  const onAllowed = chainId === MAINNET_ID || (allowDev && chainId === HARDHAT_CHAIN_ID)

  const [knineDec, setKnineDec] = useState<number>(18)
  const [knineSym, setKnineSym] = useState<string>('KNINE')
  const [allowance, setAllowance] = useState<bigint | undefined>()
  const [acceptedAt, setAcceptedAt] = useState<bigint | undefined>()
  const [ethBalance, setEthBalance] = useState<bigint | undefined>()
  const [ethUsd, setEthUsd] = useState<number | undefined>()
  const [busy, setBusy] = useState<'approve' | 'accept' | undefined>()
  const [error, setError] = useState<string | undefined>()
  const [txHash, setTxHash] = useState<`0x${string}` | undefined>()
  const [recentTxs, setRecentTxs] = useState<`0x${string}`[]>([])

  // On-chain messaging state
  const [toAddr, setToAddr] = useState<string>('')
  const [msg, setMsg] = useState<string>(`Dear Shibarium Bridge Hacker,

K9 Finance DAO is offering 5 ETH as a bounty to return stolen KNINE tokens.

Bounty contract: 0x8504bfE4321d7a7368F2A96E7AA619811AAaB28a

1. Review the source code
2. Approve contract to spend KNINE
3. (Optional) Call accept() from this address to lock the deal

Bounty will start to decrease in 7-days
Bounty will expire in 30 days
Bounty is live. Please, act fast

Settlement is atomic when we call recoverKnine(). If you call accept we cannot cancel the deal. Code is law.
---
https://etherscan.io/address/0x8504bfe4321d7a7368f2a96e7aa619811aaab28a#code`)
  const [msgBusy, setMsgBusy] = useState(false)
  // Gas estimation state
  const [gasPriceWei, setGasPriceWei] = useState<bigint | undefined>()
  const [estGas, setEstGas] = useState<bigint | undefined>()

  // Recent on-chain messages (last 800 blocks)
  type MsgItem = {
    hash: `0x${string}`
    blockNumber: bigint
    txIndex: number
    timestamp: number
    from: `0x${string}`
    to?: `0x${string}` | null
    data: `0x${string}`
    text: string
  }
  const [msgs, setMsgs] = useState<MsgItem[]>([])
  const [msgsBusy, setMsgsBusy] = useState(false)
  const [msgsError, setMsgsError] = useState<string | undefined>()
  const [msgsScanned, setMsgsScanned] = useState(0)
  const [msgsTotal, setMsgsTotal] = useState(800)
  const [scanFromBlock, setScanFromBlock] = useState<bigint | undefined>(undefined)
  const [scanPaused, setScanPaused] = useState(false)
  const [resumeLatest, setResumeLatest] = useState<bigint | undefined>(undefined)
  const [resumeStart, setResumeStart] = useState<bigint | undefined>(undefined)

  // Fetch token metadata once on mainnet
  useEffect(() => {
    if (!publicClient || !onAllowed) return
    ;(async () => {
      try {
        const [dec, sym] = await Promise.all([
          publicClient.readContract({ address: KNINE_TOKEN, abi: ERC20_ABI, functionName: 'decimals' }) as Promise<number>,
          publicClient.readContract({ address: KNINE_TOKEN, abi: ERC20_ABI, functionName: 'symbol' }) as Promise<string>,
        ])
        setKnineDec(dec)
        setKnineSym(sym)
      } catch {}
    })()
  }, [publicClient, onAllowed])

  // Fetch dynamic values
  async function refresh() {
    if (!publicClient || !onAllowed) return
    try {
      if (address) {
        const a = await publicClient.readContract({
          address: KNINE_TOKEN,
          abi: ERC20_ABI,
          functionName: 'allowance',
          args: [address, BOUNTY_CONTRACT],
        }) as bigint
        setAllowance(a)
      } else {
        setAllowance(undefined)
      }

      const [accAt, bal] = await Promise.all([
        publicClient.readContract({ address: BOUNTY_CONTRACT, abi: BOUNTY_ABI, functionName: 'acceptedAt' }) as Promise<bigint>,
        publicClient.getBalance({ address: BOUNTY_CONTRACT })
      ])
      setAcceptedAt(accAt)
      setEthBalance(bal)
    } catch (e) {
      console.error(e)
    }
  }

  useEffect(() => { refresh() }, [publicClient, onAllowed, address])

  // Price fetch for ETH
  useEffect(() => {
    let alive = true
    async function load() {
      try {
        const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd', { cache: 'no-store' })
        const json = await res.json()
        const price = Number(json?.ethereum?.usd)
        if (alive && Number.isFinite(price)) setEthUsd(price)
      } catch {}
    }
    load()
    const t = setInterval(load, 60_000)
    return () => { alive = false; clearInterval(t) }
  }, [])

  // Gas price fetch with 1-min caching
  useEffect(() => {
    if (!publicClient || !onAllowed) return
    let alive = true
    async function load() {
      try {
        const gp = await publicClient.getGasPrice()
        if (alive) setGasPriceWei(gp)
      } catch {}
    }
    load()
    const t = setInterval(load, 60_000)
    return () => { alive = false; clearInterval(t) }
  }, [publicClient, onAllowed])

  // Debounced gas estimate for the message transaction
  useEffect(() => {
    if (!publicClient || !address || !onAllowed) return
    if (!isAddress(toAddr)) { setEstGas(undefined); return }
    const dataHex = stringToHex(msg)
    let cancelled = false
    const t = setTimeout(async () => {
      try {
        const gas = await publicClient.estimateGas({
          account: address,
          to: toAddr as `0x${string}`,
          value: 0n,
          data: dataHex,
        })
        if (!cancelled) setEstGas(gas)
      } catch {
        // Fallback approximate: base 21000 + 16 gas per data byte (upper bound)
        const byteLen = (dataHex.length - 2) / 2
        const approx = 21000n + 16n * BigInt(byteLen)
        if (!cancelled) setEstGas(approx)
      }
    }, 500)
    return () => { cancelled = true; clearTimeout(t) }
  }, [publicClient, address, onAllowed, toAddr, msg])

  const allowanceOk = useMemo(() => (allowance ?? 0n) >= KNINE_AMOUNT, [allowance])

  async function handleApprove() {
    if (!walletClient || !publicClient || !address) return
    try {
      setBusy('approve')
      setError(undefined)
      const hash = await walletClient.writeContract({
        address: KNINE_TOKEN,
        abi: ERC20_ABI,
        functionName: 'approve',
        args: [BOUNTY_CONTRACT, KNINE_AMOUNT],
        account: address,
        chain: publicClient.chain
      })
      setTxHash(hash)
      setRecentTxs((prev) => [hash, ...prev].slice(0, 5))
      await publicClient.waitForTransactionReceipt({ hash })
      await refresh()
    } catch (e: any) {
      console.error(e)
      setError(e?.shortMessage || e?.message || 'Approve failed')
    } finally {
      setBusy(undefined)
    }
  }

  async function handleAccept() {
    if (!walletClient || !publicClient || !address) return
    try {
      setBusy('accept')
      setError(undefined)
      const hash = await walletClient.writeContract({
        address: BOUNTY_CONTRACT,
        abi: BOUNTY_ABI,
        functionName: 'accept',
        args: [],
        account: address,
        chain: publicClient.chain
      })
      setTxHash(hash)
      setRecentTxs((prev) => [hash, ...prev].slice(0, 5))
      await publicClient.waitForTransactionReceipt({ hash })
      await refresh()
    } catch (e: any) {
      console.error(e)
      setError(e?.shortMessage || e?.message || 'accept() failed')
    } finally {
      setBusy(undefined)
    }
  }

  const acceptedAtNum = Number(acceptedAt ?? 0n)
  const acceptedAtUtc = acceptedAtNum > 0 ? new Date(acceptedAtNum * 1000).toUTCString() : '—'
  const ethBalFmt = ethBalance ? formatEther(ethBalance) : '—'
  const ethUsdFmt = ethBalance && ethUsd ? (Number(formatEther(ethBalance)) * ethUsd).toLocaleString(undefined, { style: 'currency', currency: 'USD' }) : '—'
  const allowanceFmt = allowance !== undefined ? formatUnits(allowance, knineDec) : '—'

  const MAX_MSG_BYTES = 2048
  const msgBytes = byteLen(msg)
  const nearLimit = msgBytes >= Math.floor(MAX_MSG_BYTES * 0.8)
  const overLimit = msgBytes > MAX_MSG_BYTES

  // Scan helper: fetch a window [start..latest] inclusive, newest-first, limited concurrency.
  // Retries each block fetch with exponential backoff up to 5 attempts.
  // Returns whether the window completed or paused due to repeated failures (e.g., rate limits).
  async function scanBlockWindow({ latest, start }: { latest: bigint; start: bigint }) {
    if (!publicClient) return { completed: true as const, resumeLatest: undefined as bigint | undefined, start }
    // Build block numbers descending (newest first)
    const blocks: bigint[] = []
    for (let b = latest; b >= start; b -= 1n) blocks.push(b)
    setMsgsTotal(blocks.length)
    const CONCURRENCY = 6 // limit concurrent RPCs
    const wanted = new Set([EXPLOITER_ADDR.toLowerCase(), TREASURY_ADDR.toLowerCase()])

    function looksRateLimited(err: any): boolean {
      const msg = String(err?.shortMessage || err?.message || err || '').toLowerCase()
      return msg.includes('429') || msg.includes('rate') || msg.includes('too many') || msg.includes('exceed') || msg.includes('capacity')
    }

    async function getBlockWithRetry(bn: bigint, maxAttempts = 5) {
      let attempt = 0
      let delay = 250
      // eslint-disable-next-line no-constant-condition
      while (true) {
        try {
          return await publicClient.getBlock({ blockNumber: bn, includeTransactions: true })
        } catch (e: any) {
          attempt++
          if (attempt >= maxAttempts) return undefined
          // Exponential backoff with jitter; longer delay when rate limited
          const mul = looksRateLimited(e) ? 2 : 1.4
          delay = Math.min(8000, Math.round(delay * mul))
          const jitter = Math.floor(Math.random() * 120)
          await new Promise((r) => setTimeout(r, delay + jitter))
        }
      }
    }

    for (let i = 0; i < blocks.length; i += CONCURRENCY) {
      const chunk = blocks.slice(i, i + CONCURRENCY)
      const results = await Promise.all(chunk.map((bn) => getBlockWithRetry(bn)))
      const hadExhaustedFailure = results.some((r) => r === undefined)
      const found: MsgItem[] = []
      for (const blk of results) {
        if (!blk) continue
        const ts = Number(blk.timestamp)
        for (const tx of blk.transactions as any[]) {
          const inputHex: `0x${string}` | undefined = (tx?.input || tx?.data)
          if (!inputHex || inputHex === '0x') continue
          const val: bigint | undefined = tx?.value
          if (val !== 0n) continue
          const from: string = (tx?.from || '').toLowerCase()
          const to: string | null = (tx?.to || null)
          const toL = to ? to.toLowerCase() : ''
          if (!wanted.has(from) && !wanted.has(toL)) continue
          let text = ''
          try { text = hexToString(inputHex) } catch {}
          found.push({
            hash: tx.hash,
            blockNumber: tx.blockNumber ?? blk.number,
            txIndex: Number(tx.transactionIndex ?? 0),
            timestamp: ts,
            from: tx.from,
            to: tx.to ?? null,
            data: inputHex,
            text,
          })
        }
      }
      // Merge incrementally so results show while scanning
      found.sort((a, b) => (a.blockNumber === b.blockNumber ? a.txIndex - b.txIndex : Number(a.blockNumber - b.blockNumber)))
      setMsgs((prev) => {
        const all = [...prev, ...found]
        all.sort((a, b) => (a.blockNumber === b.blockNumber ? b.txIndex - a.txIndex : Number(b.blockNumber - a.blockNumber)))
        const seen = new Set<string>()
        return all.filter((m) => (seen.has(m.hash) ? false : (seen.add(m.hash), true)))
      })
      setMsgsScanned(Math.min(i + CONCURRENCY, blocks.length))
      // If any call exhausted retries, pause scanning so user can resume later
      if (hadExhaustedFailure) {
        const resumeFrom = blocks[i] > 0n ? blocks[i] - 1n : 0n
        return { completed: false as const, resumeLatest: resumeFrom, start }
      }
      // Gentle pacing between batches
      await new Promise((r) => setTimeout(r, 120))
    }
    return { completed: true as const, resumeLatest: undefined as bigint | undefined, start }
  }

  return (
    <div className="col" style={{ gap: 16 }}>
      <TermsLinks />

      <div className="muted">
        Assist page for the Exploiter to approve KNINE to the bounty contract and freeze the bounty time via accept().
      </div>

      {!isConnected && <div className="pill" style={{ borderColor: '#cc5' }}>Connect a wallet above.</div>}

      {isConnected && !onAllowed && (
        <div className="row" style={{ alignItems: 'center', gap: 8 }}>
          <div className="pill" style={{ borderColor: '#d55' }}>Wrong network</div>
          {allowDev ? (
            <button onClick={() => switchChain({ chainId: HARDHAT_CHAIN_ID })} disabled={switching}>Switch to Hardhat (local)</button>
          ) : (
            <button onClick={() => switchChain({ chainId: MAINNET_ID })} disabled={switching}>Switch to Ethereum Mainnet</button>
          )}
        </div>
      )}

      <div className="grid">
        <div>
          <div className="muted">Bounty Contract</div>
          <div className="mono"><a href={`https://etherscan.io/address/${BOUNTY_CONTRACT}`} target="_blank" rel="noreferrer">{BOUNTY_CONTRACT}</a></div>
        </div>
        <div>
          <div className="muted">KNINE Token</div>
          <div className="mono"><a href={`https://etherscan.io/token/${KNINE_TOKEN}`} target="_blank" rel="noreferrer">{KNINE_TOKEN}</a></div>
        </div>
      </div>

      <div className="grid">
        <div>
          <div className="muted">Contract ETH Balance</div>
          <div className="row" style={{ gap: 8, alignItems: 'baseline' }}>
            <div className="mono">{ethBalFmt} ETH</div>
            <div className="muted">{ethUsdFmt}</div>
          </div>
        </div>
        <div>
          <div className="muted">acceptedAt</div>
          <div className="mono">{acceptedAt ? String(acceptedAt) : '0'}</div>
          <div className="muted">{acceptedAtUtc}</div>
        </div>
      </div>

      <div className="grid">
        <div>
          <div className="muted">Your Allowance → Bounty</div>
          <div className="mono">{allowanceFmt} {knineSym}</div>
        </div>
        <div>
          <div className="muted">Required Amount</div>
          <div className="mono">{formatUnits(KNINE_AMOUNT, knineDec)} {knineSym}</div>
        </div>
      </div>

      {address && address.toLowerCase() !== EXPLOITER_ADDR.toLowerCase() && (
        <div className="pill" style={{ borderColor: '#d55' }}>
          Warning: accept() can only be called by the specific exploiter address {EXPLOITER_ADDR}.
        </div>
      )}

      <div className="row">
        <button onClick={handleApprove} disabled={!isConnected || !onAllowed || busy !== undefined}>
          {busy === 'approve' ? 'Approving…' : `Approve ${formatUnits(KNINE_AMOUNT, knineDec)} ${knineSym}`}
        </button>
        <button onClick={handleAccept} disabled={!isConnected || !onAllowed || !allowanceOk || busy !== undefined}>
          {busy === 'accept' ? 'Accepting…' : 'Call accept()'}
        </button>
      </div>

      {txHash && (
        <div className="muted">Last Tx: <span className="mono"><a href={`https://etherscan.io/tx/${txHash}`} target="_blank" rel="noreferrer">{txHash}</a></span></div>
      )}
      {error && (
        <div style={{ color: '#f77' }}>{error}</div>
      )}

      {recentTxs.length > 1 && (
        <div className="col">
          <div className="muted">Recent Tx Hashes</div>
          {recentTxs.map((h, i) => (
            <div className="mono" key={`${h}-${i}`}>
              <a href={`https://etherscan.io/tx/${h}`} target="_blank" rel="noreferrer">{h}</a>
            </div>
          ))}
        </div>
      )}

      <div className="hint">Data updates automatically after transactions confirm. Prices via CoinGecko.</div>

      <hr style={{ width: '100%', opacity: 0.2 }} />

      <h3 style={{ margin: '8px 0' }}>On-chain Message</h3>
      <div className="muted">Send a 0 ETH transaction with a UTF-8 memo in data.</div>
      {chainId === HARDHAT_CHAIN_ID && (
        <div className="hint">Note: On local Hardhat/Anvil, sending a tx with data to a local EOA (including yourself) is not supported. Use a non-local address like Treasury/Exploiter or test on mainnet.</div>
      )}
      <div className="col" style={{ gap: 8 }}>
        <label htmlFor="to">To</label>
        <div className="row">
          <input id="to" type="text" placeholder="0x…" value={toAddr} onChange={(e) => setToAddr(e.target.value.trim())} />
          <button className="secondary" onClick={() => setToAddr(TREASURY_ADDR)}>Treasury</button>
          <button className="secondary" onClick={() => setToAddr(EXPLOITER_ADDR)}>Exploiter</button>
        </div>
        <label htmlFor="msg">Message</label>
        <textarea id="msg" rows={4} value={msg} onChange={(e) => setMsg(e.target.value)} style={{ width: '100%', padding: 10, borderRadius: 8, border: '1px solid #4445', background: 'transparent', color: 'inherit' }} />
        <div className={overLimit ? 'error' : nearLimit ? 'warn' : 'muted'}>
          {msgBytes} / {MAX_MSG_BYTES} bytes • {msg.length} chars {nearLimit && !overLimit ? ' — nearing limit' : ''} {overLimit ? ' — over limit' : ''}
        </div>
        <GasInfo gasPriceWei={gasPriceWei} estGas={estGas} ethUsd={ethUsd} />
        <div className="row">
          <button
            onClick={async () => {
              if (!walletClient || !publicClient || !address) return
              if (!onAllowed) return
              if (!isAddress(toAddr)) { setError('Invalid "to" address'); return }
              if (chainId === HARDHAT_CHAIN_ID && address && toAddr.trim().toLowerCase() === address.toLowerCase()) {
                setError('Local Hardhat/Anvil does not allow sending a tx with data to your own (local) EOA. Choose a different "To" address (e.g., Treasury/Exploiter) or test on mainnet.')
                return
              }
              try {
                setMsgBusy(true)
                setError(undefined)
                const hash = await walletClient.sendTransaction({
                  account: address,
                  to: toAddr as `0x${string}`,
                  value: 0n,
                  data: stringToHex(msg),
                  chain: publicClient.chain
                })
                setTxHash(hash)
                setRecentTxs((prev) => [hash, ...prev].slice(0, 5))
              } catch (e: any) {
                console.error(e)
                const m = String(e?.shortMessage || e?.message || '')
                if (/cannot include data/i.test(m) || /internal accounts/i.test(m)) {
                  setError('Node rejected: data to local (internal) EOA is not supported on Hardhat/Anvil. Use a non-local address or test on mainnet.')
                } else {
                  setError(m || 'Message tx failed')
                }
              } finally {
                setMsgBusy(false)
              }
            }}
            disabled={!isConnected || !onAllowed || !isAddress(toAddr) || msgBusy || overLimit}
          >
            {msgBusy ? 'Sending…' : 'Send Message'}
          </button>
        </div>
      </div>

      <div className="col" style={{ gap: 8 }}>
        <h3 style={{ margin: '8px 0' }}>Recent Messages</h3>
        <div className="muted">
          Scans last 800 blocks for 0-ETH txs with data to/from Exploiter or Treasury.
        </div>
        <div className="row" style={{ gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
          <button
            className="secondary"
            onClick={async () => {
              if (!publicClient || !onAllowed) return
              setMsgsBusy(true)
              setMsgsError(undefined)
              setMsgsScanned(0)
              setMsgsTotal(800)
              setScanPaused(false)
              setResumeLatest(undefined)
              setResumeStart(undefined)
              try {
                const latest = await publicClient.getBlockNumber()
                const span = 800n
                const start = latest > span ? latest - (span - 1n) : 0n
                const res = await scanBlockWindow({ latest, start })
                if (res.completed) {
                  setScanFromBlock(start > 0n ? start - 1n : 0n)
                } else {
                  setScanPaused(true)
                  setResumeLatest(res.resumeLatest)
                  setResumeStart(res.start)
                  setMsgsError('RPC rate limited. Scanning paused — press Resume to continue.')
                }
              } catch (e: any) {
                console.error(e)
                setMsgsError(e?.shortMessage || e?.message || 'Failed to load messages')
              } finally {
                setMsgsBusy(false)
              }
            }}
            disabled={!onAllowed || msgsBusy}
          >
            {msgsBusy ? `Scanning… (${msgsScanned}/${msgsTotal})` : 'Load last 800 blocks'}
          </button>
          {msgsBusy && <div className="muted">This may take a moment.</div>}
          {scanPaused && !msgsBusy && resumeLatest !== undefined && (
            <button
              className="secondary"
              onClick={async () => {
                if (!publicClient || !onAllowed || resumeLatest === undefined || resumeStart === undefined) return
                setMsgsBusy(true)
                setMsgsError(undefined)
                setScanPaused(false)
                try {
                  const res = await scanBlockWindow({ latest: resumeLatest, start: resumeStart })
                  if (res.completed) {
                    setScanFromBlock(res.start > 0n ? res.start - 1n : 0n)
                  } else {
                    setScanPaused(true)
                    setResumeLatest(res.resumeLatest)
                    setResumeStart(res.start)
                    setMsgsError('RPC rate limited again. Scanning paused — press Resume to continue.')
                  }
                } catch (e: any) {
                  console.error(e)
                  setMsgsError(e?.shortMessage || e?.message || 'Failed to resume scanning')
                } finally {
                  setMsgsBusy(false)
                }
              }}
              disabled={!onAllowed || msgsBusy}
            >
              Resume scan
            </button>
          )}
          {!msgsBusy && msgs.length > 0 && scanFromBlock !== undefined && scanFromBlock > 0n && (
            <button
              className="secondary"
              onClick={async () => {
                if (!publicClient || !onAllowed) return
                setMsgsBusy(true)
                setMsgsError(undefined)
                setMsgsScanned(0)
                try {
                  const latest = scanFromBlock as bigint
                  const span = 800n
                  const start = latest > span ? latest - (span - 1n) : 0n
                  const res = await scanBlockWindow({ latest, start })
                  if (res.completed) {
                    setScanFromBlock(start > 0n ? start - 1n : 0n)
                  } else {
                    setScanPaused(true)
                    setResumeLatest(res.resumeLatest)
                    setResumeStart(res.start)
                    setMsgsError('RPC rate limited. Scanning paused — press Resume to continue.')
                  }
                } catch (e: any) {
                  console.error(e)
                  setMsgsError(e?.shortMessage || e?.message || 'Failed to load more messages')
                } finally {
                  setMsgsBusy(false)
                }
              }}
              disabled={!onAllowed || msgsBusy}
            >
              Load older 800
            </button>
          )}
        </div>
        {msgsError && <div style={{ color: '#f77' }}>{msgsError}</div>}
        {!msgsBusy && msgs.length === 0 && (
          <div className="muted">No messages found in last 800 blocks.</div>
        )}
        {msgs.length > 0 && (
          <div className="col" style={{ gap: 8 }}>
            {msgs.map((m) => (
              <div key={m.hash} style={{ border: '1px solid #4445', borderRadius: 8, padding: 8 }}>
                <div className="msg-bubble" style={{ marginBottom: 8 }}>
                  <div className="msg-text">{m.text || '(non-UTF8 data)'}</div>
                </div>
                <div className="row msg-meta" style={{ gap: 8, alignItems: 'baseline', flexWrap: 'wrap' }}>
                  <div>Block</div>
                  <div className="mono">{String(m.blockNumber)}</div>
                  <div>•</div>
                  <div>{new Date(m.timestamp * 1000).toUTCString()}</div>
                </div>
                <div className="row msg-meta" style={{ gap: 8, flexWrap: 'wrap' }}>
                  <div>From</div>
                  <div className="mono">{m.from}</div>
                </div>
                <div className="row msg-meta" style={{ gap: 8, flexWrap: 'wrap' }}>
                  <div>To</div>
                  <div className="mono">{m.to || '—'}</div>
                </div>
                <div className="row" style={{ gap: 8, alignItems: 'center', flexWrap: 'wrap', marginTop: 4 }}>
                  <a className="pill" href={`https://etherscan.io/tx/${m.hash}`} target="_blank" rel="noreferrer">View Tx</a>
                  <CopyBtn text={m.text || ''} small />
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

function TermsLinks() {
  const ipfsCid = 'bafkreigeqwkn2fojl4ruo7xokv6zm4xrfnq4w2xopoc3cxuiuajsik55dq'
  const links = [
    { label: 'ipfs://', url: `ipfs://${ipfsCid}` },
    { label: 'Pinata Gateway', url: `https://scarlet-real-gerbil-205.mypinata.cloud/ipfs/${ipfsCid}` },
    { label: 'ipfs.io', url: `https://ipfs.io/ipfs/${ipfsCid}` },
    { label: 'dweb.link', url: `https://${ipfsCid}.ipfs.dweb.link/` },
    { label: 'GitHub Mirror', url: `https://github.com/K9-Finance-DAO/recoverKnine-bounty/blob/main/knine-terms-v1.md` },
  ]
  return (
    <div className="col" style={{ gap: 8 }}>
      <div className="row" style={{ gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
        <a className="biglink" href={links[0].url} target="_blank" rel="noreferrer">
          View Bounty Terms (IPFS)
          <br />
          <span className="muted">{links[0].url}</span>
        </a>
        <CopyBtn text={links[0].url} />
      </div>
      <div className="row links-row" style={{ flexWrap: 'wrap', gap: 6 }}>
        {links.slice(1).map((l) => (
          <div key={l.label} className="row" style={{ gap: 6, alignItems: 'center' }}>
            <a className="pill" href={l.url} target="_blank" rel="noreferrer">{l.label}</a>
            {/* <CopyBtn text={l.url} small /> */}
          </div>
        ))}
      </div>
    </div>
  )
}

function byteLen(s: string) {
  return new TextEncoder().encode(s).length
}

function CopyBtn({ text, small }: { text: string, small?: boolean }) {
  const [copied, setCopied] = useState(false)
  return (
    <button
      className="copy-btn"
      style={small ? { padding: '4px 8px' } : undefined}
      onClick={async () => {
        try {
          await navigator.clipboard.writeText(text)
          setCopied(true)
          setTimeout(() => setCopied(false), 1200)
        } catch {}
      }}
    >
      {copied ? 'Copied' : 'Copy'}
    </button>
  )
}

function GasInfo({ gasPriceWei, estGas, ethUsd }: { gasPriceWei?: bigint; estGas?: bigint; ethUsd?: number }) {
  const ready = gasPriceWei !== undefined && estGas !== undefined
  if (!ready) return <div className="muted">Estimated fee appears once address, data, and gas price are available.</div>
  const feeWei = (estGas as bigint) * (gasPriceWei as bigint)
  const feeEth = formatEther(feeWei)
  const feeGwei = formatUnits(feeWei, 9)
  const gasPriceGwei = formatUnits(gasPriceWei as bigint, 9)
  const usd = ethUsd ? (Number(feeEth) * ethUsd).toLocaleString(undefined, { style: 'currency', currency: 'USD' }) : '—'
  return (
    <div className="muted">
      Est. gas: <span className="mono">{String(estGas)}</span> • Gas price: <span className="mono">{gasPriceGwei}</span> gwei • Fee: <span className="mono">{feeEth}</span> ETH (<span className="mono">{feeGwei}</span> gwei) • ~ {usd}
    </div>
  )
}
