import { useEffect, useMemo, useState } from 'react'
import { MAINNET_ID, HARDHAT_CHAIN_ID, KNINE_TOKEN, BOUNTY_CONTRACT, KNINE_AMOUNT, ERC20_ABI, BOUNTY_ABI, EXPLOITER_ADDR, TREASURY_ADDR } from '../lib/knine'
import { useAccount, useChainId, usePublicClient, useWalletClient, useSwitchChain } from 'wagmi'
import { formatEther, formatUnits, isAddress, stringToHex } from 'viem'

export function ExploiterAssist() {
  const chainId = useChainId()
  const { address, isConnected } = useAccount()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()
  const { switchChain, isPending: switching } = useSwitchChain()

  const allowDev = import.meta.env.DEV || import.meta.env.VITE_ENABLE_DEV_CHAIN === 'true'
  const onAllowed = chainId === MAINNET_ID || (allowDev && chainId === HARDHAT_CHAIN_ID)

  const [knineDec, setKnineDec] = useState<number>(18)
  const [knineSym, setKnineSym] = useState<string>('KNINE')
  const [allowance, setAllowance] = useState<bigint | undefined>()
  const [acceptedAt, setAcceptedAt] = useState<bigint | undefined>()
  const [ethBalance, setEthBalance] = useState<bigint | undefined>()
  const [ethUsd, setEthUsd] = useState<number | undefined>()
  const [busy, setBusy] = useState<'approve' | 'accept' | undefined>()
  const [error, setError] = useState<string | undefined>()
  const [txHash, setTxHash] = useState<`0x${string}` | undefined>()
  const [recentTxs, setRecentTxs] = useState<`0x${string}`[]>([])

  // On-chain messaging state
  const [toAddr, setToAddr] = useState<string>('')
  const [msg, setMsg] = useState<string>('')
  const [msgBusy, setMsgBusy] = useState(false)
  // Gas estimation state
  const [gasPriceWei, setGasPriceWei] = useState<bigint | undefined>()
  const [estGas, setEstGas] = useState<bigint | undefined>()

  // Fetch token metadata once on mainnet
  useEffect(() => {
    if (!publicClient || !onAllowed) return
    ;(async () => {
      try {
        const [dec, sym] = await Promise.all([
          publicClient.readContract({ address: KNINE_TOKEN, abi: ERC20_ABI, functionName: 'decimals' }) as Promise<number>,
          publicClient.readContract({ address: KNINE_TOKEN, abi: ERC20_ABI, functionName: 'symbol' }) as Promise<string>,
        ])
        setKnineDec(dec)
        setKnineSym(sym)
      } catch {}
    })()
  }, [publicClient, onMainnet])

  // Fetch dynamic values
  async function refresh() {
    if (!publicClient || !onMainnet) return
    try {
      if (address) {
        const a = await publicClient.readContract({
          address: KNINE_TOKEN,
          abi: ERC20_ABI,
          functionName: 'allowance',
          args: [address, BOUNTY_CONTRACT],
        }) as bigint
        setAllowance(a)
      } else {
        setAllowance(undefined)
      }

      const [accAt, bal] = await Promise.all([
        publicClient.readContract({ address: BOUNTY_CONTRACT, abi: BOUNTY_ABI, functionName: 'acceptedAt' }) as Promise<bigint>,
        publicClient.getBalance({ address: BOUNTY_CONTRACT })
      ])
      setAcceptedAt(accAt)
      setEthBalance(bal)
    } catch (e) {
      console.error(e)
    }
  }

  useEffect(() => { refresh() }, [publicClient, onAllowed, address])

  // Price fetch for ETH
  useEffect(() => {
    let alive = true
    async function load() {
      try {
        const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd', { cache: 'no-store' })
        const json = await res.json()
        const price = Number(json?.ethereum?.usd)
        if (alive && Number.isFinite(price)) setEthUsd(price)
      } catch {}
    }
    load()
    const t = setInterval(load, 60_000)
    return () => { alive = false; clearInterval(t) }
  }, [])

  // Gas price fetch with 1-min caching
  useEffect(() => {
    if (!publicClient || !onAllowed) return
    let alive = true
    async function load() {
      try {
        const gp = await publicClient.getGasPrice()
        if (alive) setGasPriceWei(gp)
      } catch {}
    }
    load()
    const t = setInterval(load, 60_000)
    return () => { alive = false; clearInterval(t) }
  }, [publicClient, onAllowed])

  // Debounced gas estimate for the message transaction
  useEffect(() => {
    if (!publicClient || !address || !onAllowed) return
    if (!isAddress(toAddr)) { setEstGas(undefined); return }
    const dataHex = stringToHex(msg)
    let cancelled = false
    const t = setTimeout(async () => {
      try {
        const gas = await publicClient.estimateGas({
          account: address,
          to: toAddr as `0x${string}`,
          value: 0n,
          data: dataHex,
        })
        if (!cancelled) setEstGas(gas)
      } catch {
        // Fallback approximate: base 21000 + 16 gas per data byte (upper bound)
        const byteLen = (dataHex.length - 2) / 2
        const approx = 21000n + 16n * BigInt(byteLen)
        if (!cancelled) setEstGas(approx)
      }
    }, 500)
    return () => { cancelled = true; clearTimeout(t) }
  }, [publicClient, address, onAllowed, toAddr, msg])

  const allowanceOk = useMemo(() => (allowance ?? 0n) >= KNINE_AMOUNT, [allowance])

  async function handleApprove() {
    if (!walletClient || !publicClient || !address) return
    try {
      setBusy('approve')
      setError(undefined)
      const hash = await walletClient.writeContract({
        address: KNINE_TOKEN,
        abi: ERC20_ABI,
        functionName: 'approve',
        args: [BOUNTY_CONTRACT, KNINE_AMOUNT],
        account: address,
        chain: publicClient.chain
      })
      setTxHash(hash)
      setRecentTxs((prev) => [hash, ...prev].slice(0, 5))
      await publicClient.waitForTransactionReceipt({ hash })
      await refresh()
    } catch (e: any) {
      console.error(e)
      setError(e?.shortMessage || e?.message || 'Approve failed')
    } finally {
      setBusy(undefined)
    }
  }

  async function handleAccept() {
    if (!walletClient || !publicClient || !address) return
    try {
      setBusy('accept')
      setError(undefined)
      const hash = await walletClient.writeContract({
        address: BOUNTY_CONTRACT,
        abi: BOUNTY_ABI,
        functionName: 'accept',
        args: [],
        account: address,
        chain: publicClient.chain
      })
      setTxHash(hash)
      setRecentTxs((prev) => [hash, ...prev].slice(0, 5))
      await publicClient.waitForTransactionReceipt({ hash })
      await refresh()
    } catch (e: any) {
      console.error(e)
      setError(e?.shortMessage || e?.message || 'accept() failed')
    } finally {
      setBusy(undefined)
    }
  }

  const acceptedAtNum = Number(acceptedAt ?? 0n)
  const acceptedAtUtc = acceptedAtNum > 0 ? new Date(acceptedAtNum * 1000).toUTCString() : '—'
  const ethBalFmt = ethBalance ? formatEther(ethBalance) : '—'
  const ethUsdFmt = ethBalance && ethUsd ? (Number(formatEther(ethBalance)) * ethUsd).toLocaleString(undefined, { style: 'currency', currency: 'USD' }) : '—'
  const allowanceFmt = allowance !== undefined ? formatUnits(allowance, knineDec) : '—'

  const MAX_MSG_BYTES = 2048
  const msgBytes = byteLen(msg)
  const nearLimit = msgBytes >= Math.floor(MAX_MSG_BYTES * 0.8)
  const overLimit = msgBytes > MAX_MSG_BYTES

  return (
    <div className="col" style={{ gap: 16 }}>
      <TermsLinks />

      <div className="muted">
        Assist page for the Exploiter to approve KNINE to the bounty contract and freeze the bounty time via accept().
      </div>

      {!isConnected && <div className="pill" style={{ borderColor: '#cc5' }}>Connect a wallet above.</div>}

      {isConnected && !onAllowed && (
        <div className="row" style={{ alignItems: 'center', gap: 8 }}>
          <div className="pill" style={{ borderColor: '#d55' }}>Wrong network</div>
          {allowDev ? (
            <button onClick={() => switchChain({ chainId: HARDHAT_CHAIN_ID })} disabled={switching}>Switch to Hardhat (local)</button>
          ) : (
            <button onClick={() => switchChain({ chainId: MAINNET_ID })} disabled={switching}>Switch to Ethereum Mainnet</button>
          )}
        </div>
      )}

      <div className="grid">
        <div>
          <div className="muted">Bounty Contract</div>
          <div className="mono"><a href={`https://etherscan.io/address/${BOUNTY_CONTRACT}`} target="_blank" rel="noreferrer">{BOUNTY_CONTRACT}</a></div>
        </div>
        <div>
          <div className="muted">KNINE Token</div>
          <div className="mono"><a href={`https://etherscan.io/token/${KNINE_TOKEN}`} target="_blank" rel="noreferrer">{KNINE_TOKEN}</a></div>
        </div>
      </div>

      <div className="grid">
        <div>
          <div className="muted">Contract ETH Balance</div>
          <div className="row" style={{ gap: 8, alignItems: 'baseline' }}>
            <div className="mono">{ethBalFmt} ETH</div>
            <div className="muted">{ethUsdFmt}</div>
          </div>
        </div>
        <div>
          <div className="muted">acceptedAt</div>
          <div className="mono">{acceptedAt ? String(acceptedAt) : '0'}</div>
          <div className="muted">{acceptedAtUtc}</div>
        </div>
      </div>

      <div className="grid">
        <div>
          <div className="muted">Your Allowance → Bounty</div>
          <div className="mono">{allowanceFmt} {knineSym}</div>
        </div>
        <div>
          <div className="muted">Required Amount</div>
          <div className="mono">{formatUnits(KNINE_AMOUNT, knineDec)} {knineSym}</div>
        </div>
      </div>

      {address && address.toLowerCase() !== EXPLOITER_ADDR.toLowerCase() && (
        <div className="pill" style={{ borderColor: '#d55' }}>
          Warning: accept() can only be called by the specific exploiter address {EXPLOITER_ADDR}.
        </div>
      )}

      <div className="row">
        <button onClick={handleApprove} disabled={!isConnected || !onAllowed || busy !== undefined}>
          {busy === 'approve' ? 'Approving…' : `Approve ${formatUnits(KNINE_AMOUNT, knineDec)} ${knineSym}`}
        </button>
        <button onClick={handleAccept} disabled={!isConnected || !onAllowed || !allowanceOk || busy !== undefined}>
          {busy === 'accept' ? 'Accepting…' : 'Call accept()'}
        </button>
      </div>

      {txHash && (
        <div className="muted">Last Tx: <span className="mono"><a href={`https://etherscan.io/tx/${txHash}`} target="_blank" rel="noreferrer">{txHash}</a></span></div>
      )}
      {error && (
        <div style={{ color: '#f77' }}>{error}</div>
      )}

      {recentTxs.length > 1 && (
        <div className="col">
          <div className="muted">Recent Tx Hashes</div>
          {recentTxs.map((h, i) => (
            <div className="mono" key={`${h}-${i}`}>
              <a href={`https://etherscan.io/tx/${h}`} target="_blank" rel="noreferrer">{h}</a>
            </div>
          ))}
        </div>
      )}

      <div className="hint">Data updates automatically after transactions confirm. Prices via CoinGecko.</div>

      <hr style={{ width: '100%', opacity: 0.2 }} />

      <h3 style={{ margin: '8px 0' }}>On-chain Message</h3>
      <div className="muted">Send a 0 ETH transaction with a UTF-8 memo in data.</div>
      <div className="col" style={{ gap: 8 }}>
        <label htmlFor="to">To</label>
        <div className="row">
          <input id="to" type="text" placeholder="0x…" value={toAddr} onChange={(e) => setToAddr(e.target.value.trim())} />
          <button className="secondary" onClick={() => setToAddr(TREASURY_ADDR)}>Treasury</button>
          <button className="secondary" onClick={() => setToAddr(EXPLOITER_ADDR)}>Exploiter</button>
        </div>
        <label htmlFor="msg">Message</label>
        <textarea id="msg" rows={4} value={msg} onChange={(e) => setMsg(e.target.value)} style={{ width: '100%', padding: 10, borderRadius: 8, border: '1px solid #4445', background: 'transparent', color: 'inherit' }} />
        <div className={overLimit ? 'error' : nearLimit ? 'warn' : 'muted'}>
          {msgBytes} / {MAX_MSG_BYTES} bytes • {msg.length} chars {nearLimit && !overLimit ? ' — nearing limit' : ''} {overLimit ? ' — over limit' : ''}
        </div>
        <GasInfo gasPriceWei={gasPriceWei} estGas={estGas} ethUsd={ethUsd} />
        <div className="row">
          <button
            onClick={async () => {
              if (!walletClient || !publicClient || !address) return
              if (!onAllowed) return
              if (!isAddress(toAddr)) { setError('Invalid "to" address'); return }
              try {
                setMsgBusy(true)
                setError(undefined)
                const hash = await walletClient.sendTransaction({
                  account: address,
                  to: toAddr as `0x${string}`,
                  value: 0n,
                  data: stringToHex(msg),
                  chain: publicClient.chain
                })
                setTxHash(hash)
                setRecentTxs((prev) => [hash, ...prev].slice(0, 5))
              } catch (e: any) {
                console.error(e)
                setError(e?.shortMessage || e?.message || 'Message tx failed')
              } finally {
                setMsgBusy(false)
              }
            }}
            disabled={!isConnected || !onAllowed || !isAddress(toAddr) || msgBusy || overLimit}
          >
            {msgBusy ? 'Sending…' : 'Send Message'}
          </button>
        </div>
      </div>
    </div>
  )
}

function TermsLinks() {
  const ipfsCid = 'bafkreibozzjt26frhbt2jssvymhnabtk44yzf4e4qbvsrmg7k2x2q4rgly'
  const links = [
    { label: 'ipfs://', url: `ipfs://${ipfsCid}` },
    { label: 'Pinata Gateway', url: `https://scarlet-real-gerbil-205.mypinata.cloud/ipfs/${ipfsCid}` },
    { label: 'ipfs.io', url: `https://ipfs.io/ipfs/${ipfsCid}` },
    { label: 'dweb.link', url: `https://${ipfsCid}.ipfs.dweb.link/` },
    { label: 'GitHub Mirror', url: `https://github.com/K9-Finance-DAO/recoverKnine-bounty/blob/main/knine-terms-v1.md` },
  ]
  return (
    <div className="col" style={{ gap: 8 }}>
      <div className="row" style={{ gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
        <a className="biglink" href={links[0].url} target="_blank" rel="noreferrer">
          View Bounty Terms (IPFS)
        </a>
        <CopyBtn text={links[0].url} />
      </div>
      <div className="row links-row" style={{ flexWrap: 'wrap', gap: 6 }}>
        {links.slice(1).map((l) => (
          <div key={l.label} className="row" style={{ gap: 6, alignItems: 'center' }}>
            <a className="pill" href={l.url} target="_blank" rel="noreferrer">{l.label}</a>
            <CopyBtn text={l.url} small />
          </div>
        ))}
      </div>
    </div>
  )
}

function byteLen(s: string) {
  return new TextEncoder().encode(s).length
}

function CopyBtn({ text, small }: { text: string, small?: boolean }) {
  const [copied, setCopied] = useState(false)
  return (
    <button
      className="copy-btn"
      style={small ? { padding: '4px 8px' } : undefined}
      onClick={async () => {
        try {
          await navigator.clipboard.writeText(text)
          setCopied(true)
          setTimeout(() => setCopied(false), 1200)
        } catch {}
      }}
    >
      {copied ? 'Copied' : 'Copy'}
    </button>
  )
}

function GasInfo({ gasPriceWei, estGas, ethUsd }: { gasPriceWei?: bigint; estGas?: bigint; ethUsd?: number }) {
  const ready = gasPriceWei !== undefined && estGas !== undefined
  if (!ready) return <div className="muted">Estimated fee appears once address, data, and gas price are available.</div>
  const feeWei = (estGas as bigint) * (gasPriceWei as bigint)
  const feeEth = formatEther(feeWei)
  const feeGwei = formatUnits(feeWei, 9)
  const gasPriceGwei = formatUnits(gasPriceWei as bigint, 9)
  const usd = ethUsd ? (Number(feeEth) * ethUsd).toLocaleString(undefined, { style: 'currency', currency: 'USD' }) : '—'
  return (
    <div className="muted">
      Est. gas: <span className="mono">{String(estGas)}</span> • Gas price: <span className="mono">{gasPriceGwei}</span> gwei • Fee: <span className="mono">{feeEth}</span> ETH (<span className="mono">{feeGwei}</span> gwei) • ~ {usd}
    </div>
  )
}
